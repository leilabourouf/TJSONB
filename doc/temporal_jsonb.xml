<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter xml:id="temporal_jsonb">
	<title>Temporal JSONB</title>

	<para>PostgreSQL provides two types for storing JSON data: <varname>json</varname> and <varname>jsonb</varname>. The <varname>json</varname> type stores an exact copy of the input text, which must be reparsed each time it is processed. On the other hand, the <varname>jsonb</varname> type stores the JSON data in a decomposed binary format that makes it slightly slower to input due to added conversion overhead, but significantly faster to process, since no reparsing is needed. The <varname>jsonb</varname> type also supports indexing.</para>

	<para>The <varname>jsonb</varname> type serves as base type for defining the temporal type <varname>tjsonb</varname>. Being a temporal type, most functions and operators described before for temporal types are also applicable for the <varname>tjsonb</varname> type. In addition, there are specific functions defined for the <varname>tjsonb</varname> type, which are derived from the functions of the <varname>jsonb</varname> type. We refer to the PostgreSQL <ulink url="https://www.postgresql.org/docs/current/datatype-json.html">documentation</ulink> for a detailed explanation of the JSON data types and their functionality.</para> 

	<sect1 xml:id="temp_jsonb">
		<title>Temporal JSONB values</title>
		<para>The temporal type <varname>tjsonb</varname> allows to represent the evolution in time of JSONB values. As all temporal types, it comes in three subtypes, namely, instant, sequence, and sequence set. Examples of <varname>tjsonb</varname> values in these subtypes are given next.</para>
		<programlisting language="sql" xml:space="preserve" format="linespecific">
-- Instant
SELECT tjsonb '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01';
-- Sequence with discrete interpolation
SELECT tjsonb '{{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02}';
-- Sequence with step interpolation
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]';
-- Sequence set
SELECT tjsonb '{[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02],
  [{"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03,
  {"vehicleId": 1, "location": "Point(3 3)"}@2001-01-04]}';
</programlisting>
		<para>As can be seen above, for the <varname>Instant</varname> subtype we need to enclose the JSONB value between quotes and escape the inner quotes, otherwise the opening brace of the JSONB value would be interpreted as the beginning of a <varname>Sequence</varname> subtype with discrete interpolation.</para>

		<para>The <varname>tjsonb</varname> type accepts type modifiers (or <varname>typmod</varname> in PostgreSQL terminology) to specify the subtype. The possible values for the subtype are <varname>Instant</varname>, <varname>Sequence</varname>, and <varname>SequenceSet</varname>. The argument is optional and if not specified for a column, values of any subtype are allowed.</para>
		<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb(Instant) '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01';
--  {"location": "Point(1 1)", "vehicleId": 1}@2001-01-01
SELECT tjsonb(Sequence) '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01';
-- ERROR: Temporal type (Instant) does not match column type (Sequence)
</programlisting>

		<para>Temporal JSONB values of sequence or sequence set subtype are converted into a normal form so that equivalent values have identical representations. For this, consecutive instant values are merged when possible. Three consecutive instant values can be merged into two if their JSONB values are equal. Also, two consecutive sequences that are adjacent and have the same end and start JSONB value can be merged into a single one. Examples of transformation into a normal form are as follows.</para>
		<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT asText(tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]');
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
   {"location": "Point(1 1)", "vehicleId": 1}@2001-01-03] */
SELECT asText(tjsonb '{[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03],
  ({"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-04]}');
/* {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01, 
   {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02, 
   {"location": "Point(2 2)", "vehicleId": 1}@2001-01-04]} */
</programlisting>
	</sect1>

	<sect1 xml:id="tjsonb_validity">
		<title>Validity of temporal JSONB values</title>

		<para>Temporal JSONB values must satisfy the constraints specified in <xref linkend="ttype_validity"/> so that they are well defined. An error is raised whenever one of these constraints are not satisfied. Examples of incorrect values are as follows.</para>
		<programlisting language="sql" xml:space="preserve" format="linespecific">
-- Null values are not allowed
SELECT tjsonb 'NULL@2001-01-01 08:05:00';
SELECT tjsonb 'Point(0 0)@NULL';
-- Base type is not a JSONB
SELECT tjsonb 'Point(0 0)@2001-01-01 08:05:00';
</programlisting>
		<para>We give next the functions and operators for temporal JSONB. Most functions and operators for temporal types described in the previous chapters can be applied for temporal JSONB types. Therefore, in the signatures of the functions, the notation <varname>base</varname> represents a <varname>jsonb</varname> and the notation <varname>ttype</varname>, represents a <varname>tjsonb</varname>. To avoid redundancy, we only present next some examples of these functions and operators for temporal JSONB values.</para>
	</sect1>

	<sect1 xml:id="tjsonb_inout">
		<title>Input and Output</title>

		<itemizedlist>
			<listitem xml:id="tjsonb_asText">
				<indexterm significance="normal"><primary><varname>asText</varname></primary></indexterm>
				<para>Return the Well-Known Text (WKT) representation</para>
				<para><varname>asText({tjsonb,tjsonb[]}) → {text,text[]}</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT asText(tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]');
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
   {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02] */
SELECT asText(ARRAY[tjsonb '"{\"vehicleId\":1, \"location\": \"Point(1 1)\"}"@2001-01-01',
  '"{\"vehicleId\": 1, \"location\": \"Point(2 2)\"}"@2001-01-02']);
/* {"{\"location\": \"Point(1 1)\", \"vehicleId\": 1}@2001-01-01",
   "{\"location\": \"Point(2 2)\", \"vehicleId\": 1}@2001-01-02"} */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_asBinary">
				<indexterm significance="normal"><primary><varname>asBinary</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>asHexWKB</varname></primary></indexterm>
				<para>Return the Well-Known Binary (WKB) or the Hexadecimal Extended Well-Known Binary (HexWKB) representation</para>
				<para><varname>asBinary(tjsonb,endian text='') → bytea</varname></para>
				<para><varname>asHexWKB(tjsonb,endian text='') → text</varname></para>
				<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT asBinary(tjsonb '"{\"vehicleId\": 1, \"location\": \"Point(1 2)\"}"@2001-01-01');
-- \x0141000138000000000000000200002008000080090000000a000000090000106c6f636174696f6e7...
SELECT asHexWKB(tjsonb '"{\"vehicleId\": 1, \"location\": \"Point(1 2)\"}"@2001-01-01');
-- 0141000138000000000000000200002008000080090000000A000000090000106C6F636174696F6E7...
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_asMFJSON">
				<indexterm significance="normal"><primary><varname>asMFJSON</varname></primary></indexterm>
				<para>Return the Moving Features JSON (MF-JSON) representation</para>
				<para><varname>asMFJSON(text) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT asMFJSON(tjsonb '[{"Position": "Point(1 1)"}@2025-01-01,
  {"Position": "Point(2 2)"}@2025-01-02]');
/* {"type":"MovingJsonb","values":[{"Position": "Point(1 1)"},{"Position": "Point(2 2)"}],
   "datetimes":["2025-01-01T00:00:00+01","2025-01-02T00:00:00+01"],
   "lower_inc":true,"upper_inc":true,"interpolation":"Step"} */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonbFromText">
				<indexterm significance="normal"><primary><varname>tjsonbFromText</varname></primary></indexterm>
				<para>Input from the Well-Known Text (WKT) representation</para>
				<para><varname>tjsonbFromText(text) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbFromText(text 
  '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]');
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
   {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02] */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonbFromBinary">
				<indexterm significance="normal"><primary><varname>tjsonbFromBinary</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tjsonbFromHexWKB</varname></primary></indexterm>
				<para>Input from the Well-Known Binary (WKB) or from the Hexadecimal Well-Known Binary (HexWKB) representation</para>
				<para><varname>tjsonbFromBinary(bytea) → tjsonb</varname></para>
				<para><varname>tjsonbFromHexWKB(text) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbFromBinary(asBinary(
  tjsonb '[{"vehicleId": 1, "location": "Point(1 2)"}@2001-01-01]'));
-- [{"location": "Point(1 2)", "vehicleId": 1}@2001-01-01]
SELECT tjsonbFromHexWKB(asHexWKB(
  tjsonb '[{"vehicleId": 1, "location": "Point(1 2)"}@2001-01-01]'));
-- [{"location": "Point(1 2)", "vehicleId": 1}@2001-01-01]
</programlisting>
			</listitem>

			<listitem xml:id="tjsonbFromMFJSON">
				<indexterm significance="normal"><primary><varname>tjsonbFromMFJSON</varname></primary></indexterm>
				<para>Input from the Moving Features JSON (MF-JSON) representation</para>
				<para><varname>tjsonbFromMFJSON(text) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbFromMFJSON('{"type": "MovingJSONB", "interpolation": "Step",
  "values": [{"Position": "Point(1 1)"}, {"Position": "Point(2 2)"}],
  "datetimes": ["2025-01-01T10:00:00Z","2025-01-01T12:00:00Z"]}');
/* [{"Position": "Point(1 1)"}@2025-01-01 11:00:00+01,
   {"Position": "Point(2 2)"}@2025-01-01 13:00:00+01] */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_constructors">
		<title>Constructors</title>

		<itemizedlist>
			<listitem xml:id="tjsonb_const">
				<indexterm significance="normal"><primary><varname>tjsonb</varname></primary></indexterm>
				<para>Constructor for temporal JSONB values having a constant value</para>
				<para><varname>tjsonb(jsonb,timestamptz) → tjsonbInst</varname></para>
				<para><varname>tjsonb(jsonb,tstzset) → tjsonbDiscSeq</varname></para>
				<para><varname>tjsonb(jsonb,tstzspan) → tjsonbContSeq</varname></para>
				<para><varname>tjsonb(jsonb,tstzspanset) → tjsonbSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb('{"vehicleId": 1, "location": "Point(1 1)"}', timestamptz '2001-01-01');
-- {"location": "Point(1 1)", "vehicleId": 1}@2001-01-01
SELECT tjsonb('{"vehicleId": 1, "location": "Point(1 1)"}', 
  tstzset '{2001-01-01, 2001-01-03, 2001-01-05}');
/* {{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-03, 
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-05} */
SELECT tjsonb('{"vehicleId": 1, "location": "Point(1 1)"}', 
  tstzspan '[2001-01-01, 2001-01-02]');
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01, 
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-02] */
SELECT tjsonb('{"vehicleId": 1, "location": "Point(1 1)"}', 
  tstzspanset '{[2001-01-01, 2001-01-02],[2001-01-03, 2001-01-04]}');
/* {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01, 
     {"location": "Point(1 1)", "vehicleId": 1}@2001-01-02],
    [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-03, 
     {"location": "Point(1 1)", "vehicleId": 1}@2001-01-04]} */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonbSeq">
				<indexterm significance="normal"><primary><varname>tjsonbSeq</varname></primary></indexterm>
				<para>Constructor for temporal JSONB values of sequence subtype</para>
				<para><varname>tjsonbSeq(tjsonbInst[]},leftInc bool=true,rightInc bool=true) →tjsonbSeq</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbSeq(ARRAY[tjsonb
  '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01',
  '"{\"vehicleId\": 1, \"location\": \"Point(2 2)\"}"@2001-01-02',
  '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-03']);
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02,
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-03] */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonbSeqSet">
				<indexterm significance="normal"><primary><varname>tjsonbSeqSet</varname></primary></indexterm>
				<para>Constructor for temporal JSONB values of sequence set subtype</para>
				<para><varname>tjsonbSeqset(tjsonb[]) → tjsonbSeqSet</varname></para>
				<para><varname>tjsonbSeqSetGaps(tjsonbInst[],maxt=NULL,maxdist=NULL) → tjsonbSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbSeqSet(ARRAY[tjsonb 
  '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]',
  '[{"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03,
    {"vehicleId": 1, "location": "Point(3 3)"}@2001-01-04]']);
/* {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02],
   [{"location": "Point(2 2)", "vehicleId": 1}@2001-01-03, 
    {"location": "Point(3 3)", "vehicleId": 1}@2001-01-04} */
SELECT tjsonbSeqSetGaps(ARRAY[tjsonb 
  '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01',
  '"{\"vehicleId\": 1, \"location\": \"Point(2 2)\"}"@2001-01-03',
  '"{\"vehicleId\": 1, \"location\": \"Point(3 3)\"}"@2001-01-05'], interval '1 day');
/* {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01],
    [{"location": "Point(2 2)", "vehicleId": 1}@2001-01-03],
    [{"location": "Point(3 3)", "vehicleId": 1}@2001-01-05]} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_conversions">
		<title>Conversions</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_tstzspan">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<para>Convert a temporal JSONB to a <varname>tstzspan</varname></para>
				<para><varname>tjsonb::tstzpan</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02]'::tstzspan;
-- [2001-01-01, 2001-01-02]
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_text">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<para>Convert between a temporal JSONB and a text</para>
				<para><varname>tjsonb::text</varname></para>
				<para><varname>text::tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT text '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02]'::tjsonb;
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-02] */
SELECT pg_typeof(tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02]'::text);
-- text
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_accessors">
		<title>Accessors</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_getValues">
				<indexterm significance="normal"><primary><varname>getValues</varname></primary></indexterm>
				<para>Return the values</para>
				<para><varname>getValues(tjsonb) → jsonbset</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT getValues(tjsonb 
  '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02]');
-- {{"location": "Point(1 1)", "vehicleId": 1}}
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_valueAtTimestamp">
				<indexterm significance="normal"><primary><varname>valueAtTimestamp</varname></primary></indexterm>
				<para>Return the value at a timestamp</para>
				<para><varname>valueAtTimestamp(tjsonb,timestamptz) → jsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT valueAtTimestamp(tjsonb 
  '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]', '2001-01-02');
-- {"location": "Point(2 2)", "vehicleId": 1}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_transformations">
		<title>Transformations</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_subtype">
				<indexterm significance="normal"><primary><varname>tjsonbInst</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tjsonbSeq</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tjsonbSeqSet</varname></primary></indexterm>
				<para>Transform a temporal JSONB to another subtype</para>
				<para><varname>tjsonbInst(tjsonb) → tjsonbInst</varname></para>
				<para><varname>tjsonbSeq(tjsonb,interp='step') → tjsonbSeq</varname></para>
				<para><varname>tjsonbSeqSet(tjsonb) → tjsonbSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbSeq(tjsonb '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01');
-- [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01]
SELECT tjsonbSeq(tjsonb '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01',
  'discrete');
-- {{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01}
SELECT tjsonbSeqSet(tjsonb '"{\"vehicleId\": 1,\"location\":\"Point(1 1)\"}"@2001-01-01');
-- {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01]}
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_setInterp">
				<indexterm significance="normal"><primary><varname>setInterp</varname></primary></indexterm>
				<para>Transform a temporal JSONB value to another interpolation</para>
				<para><varname>setInterp(tjsonb, interp) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT setInterp(tjsonb '"{\"vehicleId\": 1,\"location\": \"Point(1 1)\"}"@2001-01-01','step');
-- [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01]
SELECT setInterp(tjsonb '{[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01], 
  [{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02]}', 'discrete');
/* {{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-02} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_jsonb">
		<title>JSONB functions</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_concat">
				<indexterm significance="normal"><primary><varname>||</varname></primary></indexterm>
				<para>JSONB concatenation</para>
				<para><varname>{jsonb,tjsonb} || {jsonb,tjsonb} → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '{[{"speed":10}@2025-01-01, {"speed":20}@2025-01-02]}' ||
  '{"unit":"km"}'::jsonb;
-- {[{"unit": "km", "speed": 10}@2025-01-01, {"unit": "km", "speed": 20}@2025-01-02]}
SELECT tjsonb '{[{"speed":10}@2025-01-01, {"speed":20}@2025-01-03]}' ||
  tjsonb '{[{"Position":"Point(1 1)"}@2025-01-02, {"Position":"Point(2 2)"}@2025-01-04]}';
/* {[{"speed": 10, "Position": "Point(1 1)"}@2025-01-02, 
     {"speed": 20, "Position": "Point(2 2)"}@2025-01-03]} */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_delete">
				<indexterm significance="normal"><primary><varname>-</varname></primary></indexterm>
				<para>JSONB deletion</para>
				<para><varname>{jsonb,tjsonb} - {jsonb,tjsonb} → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '{[{"unit": "km", "speed": 10}@2025-01-01,
  {"unit": "km", "speed": 20}@2025-01-02]}' - 'unit';
-- {[{"unit": "km", "speed": 10}@2025-01-01, {"unit": "km", "speed": 20}@2025-01-01]}
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_set">
				<indexterm significance="normal"><primary><varname>tjsonb_set</varname></primary></indexterm>
				<para>Replace an existing JSONB value specified by a path with a new value</para>
				<para><varname>tjsonb_set(tjsonb,text[],jsonb,boolean=true) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb_set(tjsonb '[{"speed":10}@2025-01-01, {"speed":20}@2025-01-02]',
  ARRAY['units'], '"km/h"'::jsonb);
-- [{"speed": 10, "units": "km/h"}@2025-01-01, {"speed": 20, "units": "km/h"}@2025-01-02]
SELECT tjsonb_set(
  '[{"speed": 10, "units": "km/h"}@2025-01-01, {"speed": 20, "units": "km/h"}@2025-01-02]',
  ARRAY['units'], '"mi/h"'::jsonb);
-- [{"speed": 10, "units": "mi/h"}@2025-01-01, {"speed": 20, "units": "mi/h"}@2025-01-02]
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_restrictions">
		<title>Restrictions</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_atValues">
				<indexterm significance="normal"><primary><varname>atValues</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>minusValues</varname></primary></indexterm>
				<para>Restrict to (the complement of) a set of values</para>
				<para><varname>atValues(tjsonb,values) → tjsonb</varname></para>
				<para><varname>minusValues(tjsonb,values) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT atValues(tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03]',
  jsonb '{"vehicleId": 1, "location": "Point(2 2)"}');
-- {[{"location": "Point(2 2)", "vehicleId": 1}@2001-01-03]}
SELECT minusValues(tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03]',
  jsonb '{"vehicleId": 1, "location": "Point(2 2)"}');
/* {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-03)} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_comparisons">
		<title>Comparisons</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_comp">
				<indexterm significance="normal"><primary><varname>=</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;&gt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&gt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;=</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&gt;=</varname></primary></indexterm>
				<para>Traditional comparisons</para>
				<para><varname>tjsonb {=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=} tjsonb → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '{[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02),
  [{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02, 
   {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]}' =
  tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]';
-- true
SELECT tjsonb '{[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]}' &lt;&gt;
  tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]';
-- false
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]' &lt;
  tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]';
-- true
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_ever_always">
				<indexterm significance="normal"><primary><varname>?=</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>%=</varname></primary></indexterm>
				<para>Ever and always comparisons</para>
				<para><varname>{jsonb,tjsonb} {?=, %=} {jsonb,tjsonb} → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' ?= 
  jsonb '{"vehicleId": 1, "location": "Point(1 1)"}';
-- true
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' %= 
  jsonb '{"vehicleId": 1, "location": "Point(1 1)"}';
-- false
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_tcomp">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<para>Temporal comparisons</para>
				<para><varname>{jsonb,tjsonb} {#=, #&lt;&gt;} {jsonb,tjsonb} → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)", 0.2)@2001-01-01, 
  {"vehicleId": 1, "location": "Point(1 1)", 0.4)@2001-01-03)' #= jsonb '{"vehicleId": 1, "location": "Point(1 1)", 0.3)';
-- {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03)}
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)", 0.2)@2001-01-01, 
  {"vehicleId": 1, "location": "Point(1 1)", 0.8)@2001-01-03)' #&lt;&gt;
  tjsonb '[{"vehicleId": 1, "location": "Point(1 1)", 0.3)@2001-01-01, {"vehicleId": 1, "location": "Point(1 1)", 0.7)@2001-01-03)';
-- {[t@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_bbox_ops">
		<title>Bounding Box Operations</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_topo">
				<indexterm significance="normal"><primary><varname>&amp;&amp;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;@</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>@&gt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>~=</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>-|-</varname></primary></indexterm>
				<para>Topological operators</para>
				<para><varname>{tjsonb,tstzspan} {&amp;&amp;, &lt;@, @&gt;, ~=, -|-} {tjsonb,tstzspan} → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' &amp;&amp;
  tstzspan '[2001-01-01, 2001-03-01]';
-- true
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' @&gt;
  timestamptz '[2001-01-02]'::tstzspan;
-- true
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' -|-
  tjsonb '({"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02, 
    {"vehicleId": 1, "location": "Point(3 3)"}@2001-01-03]';
-- true
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_pos">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<para>Position operators</para>
				<para><varname>{tjsonb,tstzspan} {&lt;&lt;#, &amp;&lt;#, #&gt;&gt;, #&amp;&gt;} {tjsonb,tstzspan} → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' &lt;&lt;#
  tstzspan '[2001-01-01, 2001-03-01]';
-- false
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02, 
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03]' #&gt;&gt;
  timestamptz '[2001-01-01]'::tstzspan;
-- true
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02, 
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03]' #&amp;&gt;
  tjsonb '[{"vehicleId": 1, "location": "Point(2 2)"}@2001-01-01, 
    {"vehicleId": 1, "location": "Point(3 3)"}@2001-01-03]';
-- true
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_aggregations">
		<title>Aggregations</title>
		<para>The aggregate functions for temporal JSONB values are illustrated next.</para>

		<itemizedlist>
			<listitem xml:id="tjsonb_tCount">
				<indexterm significance="normal"><primary><varname>tCount</varname></primary></indexterm>
				<para>Temporal count</para>
				<para><varname>tCount(tjsonb) → {tintSeq,tintSeqSet}</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
WITH Temp(temp) AS (
  SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]' UNION
  SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02, 
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-04]' )
SELECT tCount(Temp)
FROM Temp;
-- {[1@2001-01-01, 2@2001-01-02, 2@2001-01-03], (1@2001-01-03, 1@2001-01-04]}
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_wCount">
				<indexterm significance="normal"><primary><varname>wCount</varname></primary></indexterm>
				<para>Window count</para>
				<para><varname>wCount(tjsonb) → {tintSeq,tintSeqSet}</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
WITH Temp(temp) AS (
  SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01, 
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]' UNION
  SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02, 
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-04]' )
SELECT wCount(Temp, interval '2 days')
FROM Temp;
-- {[1@2001-01-01, 2@2001-01-02, 2@2001-01-05], (1@2001-01-05, 1@2001-01-06]} 
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_indexing">
		<title>Indexing</title>

		<para>GiST and SP-GiST indexes can be created for table columns of temporal JSONB values. An example of index creation is follows:</para>
		<programlisting language="sql" xml:space="preserve" format="linespecific">
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
</programlisting>
		<para>The GiST and SP-GiST indexes store the bounding box for the temporal JSONB values, which is an <varname>stbox</varname>, as all spatiotemporal types.</para>

		<para>A GiST or SP-GiST index can accelerate queries involving the following operators:</para>
		<itemizedlist>
			<listitem>
				<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, which only consider the spatial dimension in temporal JSONB values,</para>
			</listitem>
			<listitem>
				<para><varname>&lt;&lt;#</varname>, <varname>&amp;&lt;#</varname>, <varname>#&amp;&gt;</varname>, <varname>#&gt;&gt;</varname>, which only consider the time dimension in temporal JSONB values,</para>
			</listitem>
			<listitem>
				<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, <varname>~=</varname>, <varname>-|-</varname>, and <varname>|=|</varname> , which consider as many dimensions as they are shared by the indexed column and the query argument.</para>
			</listitem>
		</itemizedlist>
		<para>These operators work on bounding boxes, not the entire values.</para>
	</sect1>
</chapter>

